#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>

#define MAXN 200005
#define BASE1 91138233ULL
#define MOD1 1000000007ULL
#define BASE2 97266353ULL
#define MOD2 1000000009ULL

char S[MAXN], T[MAXN];
int n, m;

unsigned long long pow1[MAXN], pow2[MAXN];
unsigned long long preS1[MAXN], preS2[MAXN];
unsigned long long preT1[MAXN], preT2[MAXN];

void build_hashes(const char *str, int len, unsigned long long pre1[], unsigned long long pre2[]) {
    unsigned long long h1 = 0, h2 = 0;
    for (int i = 0; i < len; ++i) {
        unsigned int c = (unsigned int)(unsigned char)str[i] + 1;
        h1 = (h1 * BASE1 + c) % MOD1;
        h2 = (h2 * BASE2 + c) % MOD2;
        pre1[i+1] = h1;
        pre2[i+1] = h2;
    }
}

void get_sub_hash(unsigned long long pre1[], unsigned long long pre2[], int l, int r,
                  unsigned long long *out1, unsigned long long *out2) {
    unsigned long long x1 = pre1[r] + MOD1 - (pre1[l-1] * pow1[r - (l-1)] % MOD1);
    unsigned long long x2 = pre2[r] + MOD2 - (pre2[l-1] * pow2[r - (l-1)] % MOD2);
    x1 %= MOD1; x2 %= MOD2;
    *out1 = x1; *out2 = x2;
}

void combine_hash(unsigned long long ha1, unsigned long long ha2, int lenA,
                  unsigned long long hb1, unsigned long long hb2,
                  unsigned long long *res1, unsigned long long *res2) {
    unsigned long long r1 = ( (ha1 * pow1[lenA] ) % MOD1 + hb1 ) % MOD1;
    unsigned long long r2 = ( (ha2 * pow2[lenA] ) % MOD2 + hb2 ) % MOD2;
    *res1 = r1; *res2 = r2;
}

typedef struct {
    unsigned long long key1, key2;
    int used;
    int p_first;
} HEntry;

HEntry *htable = NULL;
int hsize = 0;

void htable_init(int sz_pow2) {
    hsize = sz_pow2;
    htable = (HEntry*)malloc(sizeof(HEntry) * hsize);
    for (int i = 0; i < hsize; ++i) htable[i].used = 0;
}

void htable_free() { free(htable); htable = NULL; }

int htable_insert_or_get(unsigned long long k1, unsigned long long k2, int p) {
    unsigned long long idx = (k1 ^ (k2<<1)) & (hsize - 1);
    while (1) {
        if (!htable[idx].used) {
            htable[idx].used = 1;
            htable[idx].key1 = k1;
            htable[idx].key2 = k2;
            htable[idx].p_first = p;
            return -1;
        } else if (htable[idx].key1 == k1 && htable[idx].key2 == k2) {
            return htable[idx].p_first;
        } else {
            idx = (idx + 1) & (hsize - 1);
        }
    }
}

int main() {
    if (scanf("%s", S) != 1) return 0;
    if (scanf("%s", T) != 1) return 0;
    n = (int)strlen(S);
    m = (int)strlen(T);

    int maxlen = n + m + 5;
    pow1[0] = 1; pow2[0] = 1;
    for (int i = 1; i <= maxlen; ++i) {
        pow1[i] = (pow1[i-1] * BASE1) % MOD1;
        pow2[i] = (pow2[i-1] * BASE2) % MOD2;
    }

    build_hashes(S, n, preS1, preS2);
    build_hashes(T, m, preT1, preT2);

    int bestL = -1;
    int best_p1 = -1, best_p2 = -1;
    int best_p_first = -1;

    for (int L = 2; L <= n + m; ++L) {
        int p_lo = L - m; if (p_lo < 1) p_lo = 1;
        int p_hi = (L - 1 < n) ? (L - 1) : n;
        if (p_lo > p_hi) continue;

        int need = (p_hi - p_lo + 1) * 2;
        int sz = 1;
        while (sz < need) sz <<= 1;
        if (sz < 8) sz = 8;
        htable_init(sz);

        for (int p = p_lo; p <= p_hi; ++p) {
            int q = L - p;
            if (q < 1 || q > m) continue;

            unsigned long long hs1, hs2;
            get_sub_hash(preS1, preS2, 1, p, &hs1, &hs2);

            unsigned long long ht1, ht2;
            get_sub_hash(preT1, preT2, m - q + 1, m, &ht1, &ht2);

            unsigned long long comb1, comb2;
            combine_hash(hs1, hs2, q, ht1, ht2, &comb1, &comb2);

            int prev_p = htable_insert_or_get(comb1, comb2, p);
            if (prev_p != -1 && prev_p != p) {
                bestL = L;
                best_p_first = prev_p;
                best_p1 = prev_p;
                best_p2 = p;
                break;
            }
        }
        htable_free();
        if (bestL != -1) break;
    }

    if (bestL == -1) {
        printf("-1\n");
        return 0;
    }

    int p_out = best_p_first;
    int q_out = bestL - p_out;
    char *ans = (char*)malloc(bestL + 2);
    int idx = 0;
    for (int i = 0; i < p_out; ++i) ans[idx++] = S[i];
    for (int i = m - q_out; i < m; ++i) ans[idx++] = T[i];
    ans[idx] = '\0';
    printf("%s\n", ans);
    free(ans);
    return 0;
}

