#include <stdio.h>
#include <string.h>

#define MAX 2005
#define INF 1000000000

int n, m, k;
char park[MAX][MAX];
int spider[MAX][MAX];
int dp_prev[MAX], dp_curr[MAX];

int valid(int r, int c) {
    return r >= 0 && r < n && c >= 0 && c < m;
}

int row_after_move(int r, char d, int t) {
    if (d == 'U') return r - t;
    if (d == 'D') return r + t;
    return r;
}

int col_after_move(int c, char d, int t) {
    if (d == 'L') return c - t;
    if (d == 'R') return c + t;
    return c;
}

int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i < n; i++) scanf("%s", park[i]);

    memset(spider, 0, sizeof(spider));

    for (int r = 1; r < n; r++) {
        for (int c = 0; c < m; c++) {
            char d = park[r][c];
            if (d == '.' || r == 0) continue;

            for (int t = 0; t < n; t++) {
                int rr = row_after_move(r, d, t);
                int cc = col_after_move(c, d, t);
                if (!valid(rr, cc)) break;
                if (rr == t) spider[rr][cc]++;
            }
        }
    }

    for (int c = 0; c < m; c++)
        dp_prev[c] = spider[0][c];

    for (int r = 1; r < n; r++) {
        for (int c = 0; c < m; c++) {
            int best = INF;
            if (c > 0 && dp_prev[c - 1] < best) best = dp_prev[c - 1];
            if (dp_prev[c] < best) best = dp_prev[c];
            if (c < m - 1 && dp_prev[c + 1] < best) best = dp_prev[c + 1];
            dp_curr[c] = best + spider[r][c];
        }
        memcpy(dp_prev, dp_curr, sizeof(int) * m);
    }

    for (int c = 0; c < m; c++)
        printf("%d ", dp_prev[c]);
    printf("\n");

    return 0;
}

