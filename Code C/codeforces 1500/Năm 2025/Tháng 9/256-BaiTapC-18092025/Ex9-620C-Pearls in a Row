#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int l, r;
} Segment;

typedef struct Node {
    long long key;
    int value;
    struct Node* next;
} Node;

#define HASH_SIZE 100003

Node* hash[HASH_SIZE];

int hash_func(long long x) {
    if (x < 0) x = -x;
    return x % HASH_SIZE;
}

void set(long long key, int value) {
    int h = hash_func(key);
    Node* cur = hash[h];
    while (cur) {
        if (cur->key == key) {
            cur->value = value;
            return;
        }
        cur = cur->next;
    }
    Node* node = (Node*)malloc(sizeof(Node));
    node->key = key;
    node->value = value;
    node->next = hash[h];
    hash[h] = node;
}

int get(long long key) {
    int h = hash_func(key);
    Node* cur = hash[h];
    while (cur) {
        if (cur->key == key) return cur->value;
        cur = cur->next;
    }
    return -1;
}

void clear_hash() {
    for (int i = 0; i < HASH_SIZE; i++) {
        Node* cur = hash[i];
        while (cur) {
            Node* tmp = cur;
            cur = cur->next;
            free(tmp);
        }
        hash[i] = NULL;
    }
}

int main() {
    int n;
    scanf("%d", &n);
    long long *a = (long long*)malloc(n * sizeof(long long));
    for (int i = 0; i < n; i++) scanf("%lld", &a[i]);

    Segment *segments = (Segment*)malloc(n * sizeof(Segment));
    int segCount = 0;
    int start = 0;

    for (int i = 0; i < n; i++) {
        int last = get(a[i]);
        if (last >= start) {
            segments[segCount].l = start + 1;
            segments[segCount].r = i + 1;
            segCount++;
            start = i + 1;
            clear_hash();
        }
        set(a[i], i);
    }

    if (segCount == 0) {
        printf("-1\n");
    } else {
        if (segments[segCount-1].r != n) {
            segments[segCount-1].r = n;
        }
        printf("%d\n", segCount);
        for (int i = 0; i < segCount; i++) {
            printf("%d %d\n", segments[i].l, segments[i].r);
        }
    }

    free(a);
    free(segments);
    clear_hash();
    return 0;
}

