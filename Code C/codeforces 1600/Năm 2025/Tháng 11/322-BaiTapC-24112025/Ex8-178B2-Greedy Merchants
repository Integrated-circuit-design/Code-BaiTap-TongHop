#include <stdio.h>
#include <stdlib.h>

#define MAXN 200005
#define MAXM 400005
#define LOGN 20

int n, m, k;
int u[MAXM], v[MAXM];
int head[MAXN], nxt[MAXM], ecnt;

void addEdge(int a, int b, int id) {
    u[id] = a; v[id] = b;
    nxt[id] = head[a];
    head[a] = id;
}

int tin[MAXN], low[MAXN], timer;
int isBridge[MAXM];
void dfsBridge(int x, int parent, int eid) {
    tin[x] = low[x] = ++timer;
    for(int e = head[x]; e; e = nxt[e]) {
        int y = v[e];
        if(e == eid) continue;
        if(!tin[y]) {
            dfsBridge(y, x, e);
            if(low[y] > tin[x]) isBridge[e] = 1;
            if(low[y] < low[x]) low[x] = low[y];
        } else if(tin[y] < low[x]) low[x] = tin[y];
    }
}

int comp[MAXN], nComp;
void dfsComp(int x) {
    comp[x] = nComp;
    for(int e = head[x]; e; e = nxt[e]) {
        int y = v[e];
        if(comp[y]) continue;
        if(isBridge[e]) continue;
        dfsComp(y);
    }
}

int treeHead[MAXN], treeNext[MAXM], treeTo[MAXM], treeCnt;

void addTree(int a, int b) {
    treeCnt++;
    treeTo[treeCnt] = b;
    treeNext[treeCnt] = treeHead[a];
    treeHead[a] = treeCnt;
}

int up[LOGN][MAXN], depth[MAXN];
void dfsTree(int x, int p) {
    up[0][x] = p;
    for(int i = 1; i < LOGN; i++)
        up[i][x] = (up[i-1][x] == -1 ? -1 : up[i-1][ up[i-1][x] ]);
    for(int e = treeHead[x]; e; e = treeNext[e]) {
        int y = treeTo[e];
        if(y == p) continue;
        depth[y] = depth[x] + 1;
        dfsTree(y, x);
    }
}

int lca(int a, int b) {
    if(depth[a] < depth[b]) { int tmp = a; a = b; b = tmp; }
    int diff = depth[a] - depth[b];
    for(int i = 0; i < LOGN; i++)
        if(diff & (1 << i)) a = up[i][a];
    if(a == b) return a;
    for(int i = LOGN-1; i >= 0; i--)
        if(up[i][a] != -1 && up[i][a] != up[i][b]) { a = up[i][a]; b = up[i][b]; }
    return up[0][a];
}

long long val[MAXN];
long long dfsSum(int x, int p) {
    long long s = val[x];
    for(int e = treeHead[x]; e; e = treeNext[e]) {
        int y = treeTo[e];
        if(y == p) continue;
        s += dfsSum(y, x);
    }
    val[x] = s;
    return s;
}

int sList[MAXN], tList[MAXN];

int main() {
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= m; i++) {
        int a, b;
        scanf("%d %d", &a, &b);
        addEdge(a, b, i);
        addEdge(b, a, i + m);
    }

    dfsBridge(1, -1, -1);

    for(int i = 1; i <= n; i++)
        if(!comp[i]) { nComp++; dfsComp(i); }

    for(int i = 1; i <= m; i++) {
        int a = comp[u[i]], b = comp[v[i]];
        if(a != b && isBridge[i]) {
            addTree(a, b);
            addTree(b, a);
        }
    }

    dfsTree(1, -1);

    scanf("%d", &k);
    for(int i = 1; i <= k; i++) {
        int s, t;
        scanf("%d %d", &s, &t);
        sList[i] = comp[s];
        tList[i] = comp[t];
        if(sList[i] == tList[i]) continue;
        int c = lca(sList[i], tList[i]);
        val[sList[i]] += 1;
        val[tList[i]] += 1;
        val[c] -= 2;
    }

    dfsSum(1, -1);

    for(int i = 1; i <= k; i++) {
        if(sList[i] == tList[i]) printf("0\n");
        else {
            int c = lca(sList[i], tList[i]);
            long long res = val[sList[i]] + val[tList[i]] - 2LL * val[c];
            printf("%lld\n", res);
        }
    }

    return 0;
}

